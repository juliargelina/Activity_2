class ScheduleSlot:

    '''
    Represents a schedule slot in the Student Counseling Data Management System.
    This class contains attributes and methods related to schedule slots.
    '''
    def __init__(self, slot_id, date, start_time, end_time, status='available'):
        '''
        Initializes a new instance of the ScheduleSlot class.
        
        Parameters:
        slot_id: Unique identifier for the schedule slot.
        date: Date of the schedule slot.
        start_time: Start time of the schedule slot.
        end_time: End time of the schedule slot.
        status: Status of the schedule slot (default is 'available').
        '''
        self.__slot_id = slot_id
        self.__date = date
        self.__start_time = start_time
        self.__end_time = end_time
        self.__status = status  # Status can be 'available', 'booked' or 'cancelled'
        self.__duration = self.__compute_slot_duration()  # Compute the duration of the slot

    def mark_as_booked(self):
        '''
        Marks the schedule slot as booked.
        '''
        self.__status = 'booked'

    def mark_as_available(self):
        '''
        Marks the schedule slot as available.
        '''
        self.__status = 'available'

    def mark_as_cancelled(self):
        '''
        Marks the schedule slot as cancelled.
        '''
        self.__status = 'cancelled'

    def update_schedule_slot(self, date=None, start_time=None, end_time=None, status=None):
        '''
        Updates the schedule slot with the provided parameters.
        '''
        if date:
            self.__date = date
        if start_time:
            self.__start_time = start_time
        if end_time:
            self.__end_time = end_time
        if status:
            self.__status = status

    def get_schedule_slot_details(self):
        '''
        Returns the details of the schedule slot as a dictionary.
        '''
        return {
            'slot_id': self.__slot_id,
            'date': self.__date,
            'start_time': self.__start_time,
            'end_time': self.__end_time,
            'status': self.__status
        }

    def __compute_slot_duration(self):
        '''
        Computes the duration of the schedule slot.
        '''
        return self.__end_time - self.__start_time  # Assuming start_time and end_time are datetime objects

class SessionNotes:
    def __init__(self, session_notes_id, title, notes, added_by, date_added=None):
        self.__session_notes_id = session_notes_id
        self.__title = title
        self.__notes = notes
        self.__added_by = added_by
        self.__date_added = date_added if date_added else datetime.now()

    def update_session_notes(self, title=None, notes=None):
        if title:
            self.__title = title
        if notes:
            self.__notes = notes

    def get_session_notes(self):
        return {
            'session_notes_id': self.__session_notes_id,
            'title': self.__title,
            'notes': self.__notes,
            'added_by': self.__added_by.get_details(),
            'date_added': self.__date_added
        }

class Session:
    def __init__(self, session_id, session_schedule, student, counselor):
        self.__session_id = session_id
        self.__session_schedule = session_schedule
        self.__student = student
        self.__counselor = counselor
        self.__session_notes = None

    def update_session_details(self, session_schedule=None, student=None, counselor=None):
        if session_schedule:
            self.__session_schedule = session_schedule
        if student:
            self.__student = student
        if counselor:
            self.__counselor = counselor
    
    def get_session_details(self):
        return {
            'session_id': self.__session_id,
            'session_schedule': self.__session_schedule,
            'student': self.__student,
            'counselor': self.__counselor,
            'session_notes': self.__session_notes
        }


###### YOU MUST EDIT THE CLASSES BELOW ######

###### SUPPLY THE ATTRIBUTES AND METHODS FOR GUIDANCE SESSION BASED ON THE SPECIFICATIONS ######
###GUIDANCESESSION
class GuidanceSession(Session):
    def __init__(self, session_id, session_schedule, student, counselor,
                 session_notes, guidance_area, academic_concerns,
                 social_concerns, is_resolved, is_followup_needed):
        super().__init__(session_id, session_schedule, student, counselor)

        self.__session_notes = session_notes  
        self.__session_schedule = session_schedule  

        self.__guidance_area = guidance_area
        self.__academic_concerns = academic_concerns
        self.__social_concerns = social_concerns
        self.__is_resolved = is_resolved
        self.__is_followup_needed = is_followup_needed

###link session notes

    def add_session_notes(self, session_notes):
        self._Session__session_notes = session_notes

    def get_session_notes(self):
        return (
            self._Session__session_notes.get_session_notes()
            if self._Session__session_notes else None
        )

###get get
    def get_guidance_area(self):
        return self.__guidance_area

    def get_academic_concerns(self):
        return self.__academic_concerns

    def get_social_concerns(self):
        return self.__social_concerns

    def get_is_resolved(self):
        return self.__is_resolved

    def get_is_followup_needed(self):
        return self.__is_followup_needed

 ###update update
    
    def update_guidance_area(self, guidance_area):
        self.__guidance_area = guidance_area

    def update_academic_concerns(self, academic_concerns):
        self.__academic_concerns = academic_concerns

    def update_social_concerns(self, social_concerns):
        self.__social_concerns = social_concerns

    def update_is_resolved(self, status):
        if status == True:
            self.__is_resolved = "Session is Resolved"
            print(self.__is_resolved)
        elif status == False:
            self.__is_resolved = "Session is Not Resolved"
            print(self.__is_resolved)
        else:
            raise ValueError('Please choose only between True/False')

    def update_is_followup_needed(self, status):
        if status == True:
            self.__is_followup_needed = "Student needs a follow-up session"
            print(self.__is_followup_needed)
        elif status == False:
            self.__is_followup_needed = "No follow-up needed. Session resolved"
            print(self.__is_followup_needed)
        else:
            raise ValueError('Please choose only between True/False')
    
from datetime import datetime

# Dummy Counselor class just for testing
class Counselor:
    def __init__(self, name):
        self.__name = name
    def get_details(self):
        return {"name": self.__name}

# create a counselor and a student
counselor = Counselor("Dr. Reyes")
student = "Juan Dela Cruz"

# create a session note
notes1 = SessionNotes(session_notes_id="SN001", 
                      title="First Meeting",
                      notes="Talked about time management", 
                      added_by=counselor)

# create a guidance session
gs1 = GuidanceSession(
    session_id="GS001",
    session_schedule="2025-08-21 10:00",
    student=student,
    counselor=counselor,
    session_notes=None,   # start with no notes
    guidance_area="Academic Planning",
    academic_concerns=["Study Skills", "Time Management"],
    social_concerns=["Peer Relationships"],
    is_resolved="True",
    is_followup_needed="False"
)


# === Access attributes and methods in the session notes ===
session_notes_dict = notes1.get_session_notes()
print(f"Session Notes ID: {session_notes_dict['session_notes_id']}")
print(f"Title: {session_notes_dict['title']}")
print(f"Notes: {session_notes_dict['notes']}")
print(f"Added By: {session_notes_dict['added_by']}")
print(f"Date Added: {session_notes_dict['date_added']}")

# === Access attributes and methods in the subclass ===
print(f"Guidance Area: {gs1.get_guidance_area()}")
print(f"Academic Concerns: {gs1.get_academic_concerns()}")
print(f"Social Concerns: {gs1.get_social_concerns()}")
print(f"Is Resolved? {gs1.get_is_resolved()}")
print(f"Follow-up Needed? {gs1.get_is_followup_needed()}")


# === Update some values ===
gs1.update_is_resolved(True)      
gs1.update_is_followup_needed(False)  
gs1.update_guidance_area("Scholarship Inquiry")

print("\nAfter updates:")
print(f"Guidance Area: {gs1.get_guidance_area()}")
print(f"Is Resolved? {gs1.get_is_resolved()}")
print(f"Follow-up Needed? {gs1.get_is_followup_needed()}")

