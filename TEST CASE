'''
Student Counseling Data Management System (SCDMS): Counselor Module
This class represents the counselor module of the SCDMS.

This is the implementation of the Counselor class and its subclasses.
'''
class ScheduleSlot:

    '''
    Represents a schedule slot in the Student Counseling Data Management System.
    This class contains attributes and methods related to schedule slots.
    '''
    def __init__(self, slot_id, date, start_time, end_time, status='available'):
        '''
        Initializes a new instance of the ScheduleSlot class.
        
        Parameters:
        slot_id: Unique identifier for the schedule slot.
        date: Date of the schedule slot.
        start_time: Start time of the schedule slot.
        end_time: End time of the schedule slot.
        status: Status of the schedule slot (default is 'available').
        '''
        self.__slot_id = slot_id
        self.__date = date
        self.__start_time = start_time
        self.__end_time = end_time
        self.__status = status  # Status can be 'available', 'booked' or 'cancelled'
        self.__duration = self.__compute_slot_duration()  # Compute the duration of the slot

    def mark_as_booked(self):
        '''
        Marks the schedule slot as booked.
        '''
        self.__status = 'booked'

    def mark_as_available(self):
        '''
        Marks the schedule slot as available.
        '''
        self.__status = 'available'

    def mark_as_cancelled(self):
        '''
        Marks the schedule slot as cancelled.
        '''
        self.__status = 'cancelled'

    def update_schedule_slot(self, date=None, start_time=None, end_time=None, status=None):
        '''
        Updates the schedule slot with the provided parameters.
        '''
        if date:
            self.__date = date
        if start_time:
            self.__start_time = start_time
        if end_time:
            self.__end_time = end_time
        if status:
            self.__status = status

    def get_schedule_slot_details(self):
        '''
        Returns the details of the schedule slot as a dictionary.
        '''
        return {
            'slot_id': self.__slot_id,
            'date': self.__date,
            'start_time': self.__start_time,
            'end_time': self.__end_time,
            'status': self.__status
        }

    def __compute_slot_duration(self):
        '''
        Computes the duration of the schedule slot.
        '''
        return self.__end_time - self.__start_time  # Assuming start_time and end_time are datetime objects

class SessionNotes:
    def __init__(self, session_notes_id, title, notes, added_by, date_added=None):
        self.__session_notes_id = session_notes_id
        self.__title = title
        self.__notes = notes
        self.__added_by = added_by
        self.__date_added = date_added if date_added else datetime.now()

    def update_session_notes(self, title=None, notes=None):
        if title:
            self.__title = title
        if notes:
            self.__notes = notes

    def get_session_notes(self):
        return {
            'session_notes_id': self.__session_notes_id,
            'title': self.__title,
            'notes': self.__notes,
            'added_by': self.__added_by.get_details(),
            'date_added': self.__date_added
        }

class Session:
    def __init__(self, session_id, session_schedule, student, counselor):
        self.__session_id = session_id
        self.__session_schedule = session_schedule
        self.__student = student
        self.__counselor = counselor
        self.__session_notes = None

    def update_session_details(self, session_schedule=None, student=None, counselor=None):
        if session_schedule:
            self.__session_schedule = session_schedule
        if student:
            self.__student = student
        if counselor:
            self.__counselor = counselor
    
    def get_session_details(self):
        return {
            'session_id': self.__session_id,
            'session_schedule': self.__session_schedule,
            'student': self.__student,
            'counselor': self.__counselor,
            'session_notes': self.__session_notes
        }


###### YOU MUST EDIT THE CLASSES BELOW ######

###### SUPPLY THE ATTRIBUTES AND METHODS FOR GUIDANCE SESSION BASED ON THE SPECIFICATIONS ######
###GUIDANCESESSION
class GuidanceSession(Session):
    def __init__(self, session_id, session_schedule, student, counselor,
                 session_notes, guidance_area, academic_concerns,
                 social_concerns, is_resolved, is_followup_needed):
        super().__init__(session_id, session_schedule, student, counselor)

        self.__session_notes = session_notes  
        self.__session_schedule = session_schedule  

        self.__guidance_area = guidance_area
        self.__academic_concerns = academic_concerns
        self.__social_concerns = social_concerns
        self.__is_resolved = is_resolved
        self.__is_followup_needed = is_followup_needed

###link session notes

    def add_session_notes(self, session_notes):
        self._Session__session_notes = session_notes

    def get_session_notes(self):
        return (
            self._Session__session_notes.get_session_notes()
            if self._Session__session_notes else None
        )

###get get
    def get_guidance_area(self):
        return self.__guidance_area

    def get_academic_concerns(self):
        return self.__academic_concerns

    def get_social_concerns(self):
        return self.__social_concerns

    def get_is_resolved(self):
        return self.__is_resolved

    def get_is_followup_needed(self):
        return self.__is_followup_needed

 ###update update
    
    def update_guidance_area(self, guidance_area):
        self.__guidance_area = guidance_area

    def update_academic_concerns(self, academic_concerns):
        self.__academic_concerns = academic_concerns

    def update_social_concerns(self, social_concerns):
        self.__social_concerns = social_concerns

    def update_is_resolved(self, status):
        if status == True:
            self.__is_resolved = "Session is Resolved"
            print(self.__is_resolved)
        elif status == False:
            self.__is_resolved = "Session is Not Resolved"
            print(self.__is_resolved)
        else:
            raise ValueError('Please choose only between True/False')

    def update_is_followup_needed(self, status):
        if status == True:
            self.__is_followup_needed = "Student needs a follow-up session"
            print(self.__is_followup_needed)
        elif status == False:
            self.__is_followup_needed = "No follow-up needed. Session resolved"
            print(self.__is_followup_needed)
        else:
            raise ValueError('Please choose only between True/False')
    
from datetime import datetime

# Dummy Counselor class just for testing
class Counselor:
    def __init__(self, name):
        self.__name = name
    def get_details(self):
        return {"name": self.__name}

# create a counselor and a student
counselor = Counselor("Dr. Reyes")
student = "Juan Dela Cruz"

# create a session note
notes1 = SessionNotes(session_notes_id="SN001", 
                      title="First Meeting",
                      notes="Talked about time management", 
                      added_by=counselor)

# create a guidance session
gs1 = GuidanceSession(
    session_id="GS001",
    session_schedule="2025-08-21 10:00",
    student=student,
    counselor=counselor,
    session_notes=None,   # start with no notes
    guidance_area="Academic Planning",
    academic_concerns=["Study Skills", "Time Management"],
    social_concerns=["Peer Relationships"],
    is_resolved="True",
    is_followup_needed="False"
)


# === Access attributes and methods in the session notes ===
session_notes_dict = notes1.get_session_notes()
print(f"Session Notes ID: {session_notes_dict['session_notes_id']}")
print(f"Title: {session_notes_dict['title']}")
print(f"Notes: {session_notes_dict['notes']}")
print(f"Added By: {session_notes_dict['added_by']}")
print(f"Date Added: {session_notes_dict['date_added']}")

# === Access attributes and methods in the subclass ===
print(f"Guidance Area: {gs1.get_guidance_area()}")
print(f"Academic Concerns: {gs1.get_academic_concerns()}")
print(f"Social Concerns: {gs1.get_social_concerns()}")
print(f"Is Resolved? {gs1.get_is_resolved()}")
print(f"Follow-up Needed? {gs1.get_is_followup_needed()}")


# === Update some values ===
gs1.update_is_resolved(True)      
gs1.update_is_followup_needed(False)  
gs1.update_guidance_area("Scholarship Inquiry")

print("\nAfter updates:")
print(f"Guidance Area: {gs1.get_guidance_area()}")
print(f"Is Resolved? {gs1.get_is_resolved()}")
print(f"Follow-up Needed? {gs1.get_is_followup_needed()}")
###### THIS IS THE COUNSELOR SUPERCLASS. DO NOT EDIT THIS CLASS ######
class Counselor:
    '''
    Represents a counselor in the Student Counseling Data Management System.
    '''

    def __init__(self, counselor_id, name, license_number):
        '''
        Initializes a new instance of the Counselor class.
        Parameters:
        id_number: Unique identifier for the counselor.
        name: Full name of the counselor.
        specialization: Area of expertise or specialization of the counselor.
        '''
        self.__counselor_id = counselor_id            # Unique identifier
        self.__name = name                            # Full name of the counselor
        self.__email_address = None                   # Email address of the counselor
        self.__mobile_no = None                       # Mobile number of the counselor
        self.__license_number = license_number        # License number of the counselor
        self.__schedule = []                          # Schedule of counseling sessions

    def get_details(self):
        ''' Returns a dictionary containing the counselor's details. '''
        return {
            "id number": self.__counselor_id,
            "name": self.__name,
            "email address": self.__email_address,
            "mobile no": self.__mobile_no,
            "license number": self.__license_number,
            "schedule" : self.__schedule
        }
    
    def get_schedule(self):
        ''' Returns the schedule of counseling sessions. '''
        return self.__schedule
    
    def update_counselor_details(self, name=None, email_address=None, mobile_no=None, schedule=None):
        ''' Updates the counselor's details. '''
        if name:                                    # Update name if provided
            self.__name = name
        if email_address:                           # Update email address if provided
            self.__email_address = email_address
        if mobile_no:                               # Update mobile number if provided
            self.__mobile_no = mobile_no
        if schedule:                                # Update schedule if provided
            self.__schedule = schedule

###### DO NOT EDIT THE COUNSELOR SUPER CLASS ABOVE ######

###### YOU MUST EDIT THE CLASSES BELOW ######

###### SUPPLY THE ATTRIBUTES AND METHODS FOR GUIDANCE COUNSELOR BASED ON THE SPECIFICATIONS ######

class GuidanceCounselor(Counselor):
    '''
    Represents a guidance counselor, inheriting from the Counselor class.
    '''
    def __init__(self, counselor_id, name, license_number, academic_specialties=None, support_programs=None, disciplinary_liaison=False):
        super().__init__(counselor_id, name, license_number)
        self.__academic_specialties = academic_specialties or []  # List of academic specialties
        self.__support_programs = support_programs or []          # List of student support programs
        self.__disciplinary_liaison = disciplinary_liaison        # Boolean: is liaison or not

    def get_academic_specialties(self):
        ''' Returns the academic specialties of the guidance counselor. '''
        return self.__academic_specialties
    
    def update_academic_specialties(self, new_specialties):
        ''' Updates the academic specialties. '''
        self.__academic_specialties = new_specialties
    
    def get_student_support_programs(self):
        ''' Returns the student support programs handled. '''
        return self.__support_programs
    
    def update_student_support_programs(self, new_programs):
        ''' Updates the support programs list. '''
        self.__support_programs = new_programs
    
    def get_disciplinary_liaison(self):
        ''' Returns True if the counselor acts as a disciplinary liaison. '''
        return self.__disciplinary_liaison
    
    def update_disciplinary_liaison(self, status):
        ''' Updates the disciplinary liaison status. '''
        self.__disciplinary_liaison = status

###### SUPPLY THE ATTRIBUTES AND METHODS FOR CAREER COUNSELOR BASED ON THE SPECIFICATIONS ######
class CareerCounselor(Counselor):
    '''
    Represents a career counselor, inheriting from the Counselor class.
    '''
    
    def __init__(self, counselor_id, name, license_number, industry_expertise=None, career_tools=None, alumni_connections=None):
        super().__init__(counselor_id, name, license_number)
        self.__industry_expertise = industry_expertise or []      # List of industries they specialize in
        self.__career_tools = career_tools or []                  # List of career assessment tools
        self.__alumni_connections = alumni_connections or []      # List of alumni connections

    def get_industry_expertise(self):
        ''' Returns the list of industry expertise. '''
        return self.__industry_expertise
    
    def update_industry_expertise(self, new_expertise):
        ''' Updates the industry expertise list. '''
        self.__industry_expertise = new_expertise
    
    def get_career_assessment_tools(self):
        ''' Returns the list of career assessment tools. '''
        return self.__career_tools
    
    def update_career_assessment_tools(self, new_tools):
        ''' Updates the career assessment tools. '''
        self.__career_tools = new_tools
    
    def get_alumni_network_connections(self):
        ''' Returns the alumni network connections. '''
        return self.__alumni_connections
    
    def update_alumni_network_connections(self, new_connections):
        ''' Updates the alumni network connections. '''
        self.__alumni_connections = new_connections

###### SUPPLY THE ATTRIBUTES AND METHODS FOR MENTAL HEALTH COUNSELOR BASED ON THE SPECIFICATIONS ######
class MentalHealthCounselor(Counselor):
    '''
    Represents a mental health counselor, inheriting from the Counselor class.
    '''

    def __init__(self, counselor_id, name, license_number, specialization=None, therapeutic_approaches=None):
        super().__init__(counselor_id, name, license_number)
        self.__specialization = specialization or ""                # Area of specialization (e.g., clinical psychology)
        self.__therapeutic_approaches = therapeutic_approaches or [] # List of therapeutic approaches (e.g., CBT, mindfulness)

    def get_specialization(self):
        ''' Returns the specialization of the counselor. '''
        return self.__specialization
    
    def update_specialization(self, new_specialization):
        ''' Updates the specialization of the counselor. '''
        self.__specialization = new_specialization
    
    def get_approaches(self):
        ''' Returns the list of therapeutic approaches used. '''
        return self.__therapeutic_approaches
    
    def update_therapeutic_approaches(self, new_approaches):
        ''' Updates the therapeutic approaches. '''
        self.__therapeutic_approaches = new_approaches

# --- Create instances of each counselor subclass ---

# Guidance Counselor
role = "disciplinary"   # try changing this to "academic"

gc = GuidanceCounselor(
    counselor_id="GC001",
    name="Ms. Santos",
    license_number="LIC12345",
    academic_specialties=["Mathematics", "Science"],
    support_programs=["Peer Mentoring", "Academic Coaching"],
    disciplinary_liaison= "Yes" if role == "disciplinary" else "Not disciplinary liaison"
)

def get_disciplinary_liaison(self):
    ''' Returns True if the counselor acts as a disciplinary liaison. '''
    return self.__disciplinary_liaison


gc.update_counselor_details(
    email_address= "ms.santos@school.edu",
    mobile_no= "0917-123-4567",
    schedule=("Monday 9AM-11AM", "Wednesday 2PM-4PM")
)

# Career Counselor
cc = CareerCounselor(
    counselor_id="CC001",
    name="Mr. Reyes",
    license_number="LIC67890",
    industry_expertise=["Engineering", "IT"],
    career_tools=["Aptitude Test", "Personality Test"],
    alumni_connections=["Eng. Dela Cruz", "IT Specialist"]
)
cc.update_counselor_details(
    email_address="mr.reyes@careercenter.org",
    mobile_no="0920-987-6543",
    schedule=["Tuesday 10AM-12PM", "Thursday 1PM-3PM"]
)

# Mental Health Counselor
mhc = MentalHealthCounselor(
    counselor_id="MHC001",
    name="Dr. Cruz",
    license_number="LIC54321",
    specialization="Clinical Psychology",
    therapeutic_approaches=["CBT", "Mindfulness"]
)
mhc.update_counselor_details(
    email_address="dr.cruz@clinic.com",
    mobile_no="0998-555-1122",
    schedule=["Friday 9AM-5PM"]
)

# --- Print details in clean format ---

print("\nCareer Counselor Details: \n")
cc_details = cc.get_details()
print(f"ID Number: {cc_details['id number']}")  # Corrected key
print(f"Name: {cc_details['name']}")
print(f"Email Address: {cc_details['email address']}")  # Corrected key
print(f"Mobile No: {cc_details['mobile no']}")  # Corrected key
print(f"License Number: {cc_details['license number']}")
print(f"Schedule: {', '.join(cc_details['schedule'])}")
print(f"Industry Expertise: {', '.join(cc.get_industry_expertise())}")
print(f"Career Tools: {', '.join(cc.get_career_assessment_tools())}")
print(f"Alumni Connections: {', '.join(cc.get_alumni_network_connections())}")

print("\n Guidance Counselor Details:\n")
gc_details = gc.get_details()
print(f"ID Number: {gc_details['id number']}")  # Corrected key
print(f"Name: {gc_details['name']}")
print(f"Email Address: {gc_details['email address']}")  # Corrected key
print(f"Mobile No: {gc_details['mobile no']}")  # Corrected key
print(f"License Number: {gc_details['license number']}")
print(f"Schedule: {', '.join(gc_details['schedule'])}")
print(f"Specialties: {', '.join(gc.get_academic_specialties())}")
print(f"Programs: {', '.join(gc.get_student_support_programs())}")
print(f"Disciplinary Liaison: {gc.get_disciplinary_liaison()}")

print("\nMental Health Counselor Details:\n")
mhc_details = mhc.get_details()
print(f"ID Number: {mhc_details['id number']}")  # Corrected key
print(f"Name: {mhc_details['name']}")
print(f"Email Address: {mhc_details['email address']}")  # Corrected key
print(f"Mobile No: {mhc_details['mobile no']}")  # Corrected key
print(f"License Number: {mhc_details['license number']}")
print(f"Schedule: {', '.join(mhc_details['schedule'])}")
print(f"Specialization: {mhc.get_specialization()}")
print(f"Therapeutic Approaches: {', '.join(mhc.get_approaches())}")
